In order to achieve good software engineering design, we have used a range of
methods to eliminate design smells and follow the design principles.

A major aspect of good SE design is abstraction. Abstraction is the process of removing granular details from highly used functions into lower level functions. We have used abstraction extensively through the project, in particular the multiple classes we use to store our data. For each class, we have written methods pertaining to the interaction with the class variables. This includes “get” style method to access variables and methods that directly edit or add to the class variables. This eliminates many design smells such as rigidity, fragility, immobility. By only having a high level view of the class, this also improves understandability of code as low level knowledge of how data is stored is not required. Abstraction has also been implemented through the extensive use of functions. A large majority of error checking and data editing is done through function calls. This also allows for unit testing of specific functions. While it is possible to explain code through the use of comments, functions are self commenting and thus give a good idea of the program flow. In addition, these functions allow more dependency to be shifted into more easily changeable functions.

We have created and maintained a single helper function file that houses all functions from which our other files import form. This allows us to eliminate repetition of code throughout our files. This makes implementing any changes to these functions much easier, reducing rigidity, immobility and needless repetition (DRY). By having a centralised file, we can avoid files function calling from many other files, leading to a high interdependence between the files (coupling). By avoiding a high interdependence, we can avoid rigidity problems with changes in one module breaking code in another. This also allows for multiple members to be working on multiple modules at the same time and still maintaining working code.

Rigidity of our code has been improved by replacing hard coded variables with constant variables such as max name length of 20 characters as MAX_NAME_LENGTH. This allows for future potential changes to be handled in a more efficient manner by changing the constant value, rather than adjusting each value throughout the code. In addition, it also improves code readability and clarity with constant names that reflect the code's purpose, rather than just a concrete number. This allows for easier manipulation of commonly used variables which provides us with a simpler method of maintenance and provides. As this was implemented throughout, making changes to one variable will not cause the program to break, as it would if they were hard coded in. This improves our viscosity, and makes our code more maintainable as future changes arise.

While converting input to the correct type, it is necessary to handle exceptions
and change them from the default ValueError to our custom ValueError so that the
message can be displayed correctly on the frontend. Instead of using the standard python parsers to typecast such as int() we abstracted this as to_int() to allow for exception handling such as “Value was not of type int” rather than checking each input individually.

Refactored nearly duplicate function "valid_u_id" which found a user and returned
either true or false and get_user_by_u_id which would return None if it was not a valid u_id. Replacing the valid_u_id with a check that get_user_by_u_id returns an object not None. This simplified our code and avoided needless complexity that would make the code harder to understand and maintain.

Decorators allow us to add functionality to a function without altering the function itself. We decided to use decorators for testing a valid token was given to the function as a parameter. This is because this valid token check is repeated many times, by wrapping the functions we can eliminate the repetition and make future changes to the valid token function easier.

Since the only react implemented on the frontend was 'like' there were some instances where we were using this by always accessing and comparing to the one element on the reacts array. This has been changed to allow more reacts to be added by looping over the reacts array and stopping when the ID matches the react we are looking for. This allows for our code to be more easily maintained and further developed in the future. 

We have refactored code that was written at the start of the project with code that better utilises python’s tools to avoid overcomplexity. One place we have done this is with the create_long_string function which creates a string of 1000 length for testing purposes. Initially, we just had a file of 1000 characters for which we read into a string. We later replaced this with “a” * 1000. This reduced the complexity of having to read files and thus in the long term, will make our code more maintainable and understandable.
